"""
Django models for compliance app.
Auto-generated by Nzila Code Generator — 2026-02-17

DO NOT EDIT manually unless you know what you're doing.
Re-run the generator to overwrite.
"""

import uuid

from django.contrib.postgres.fields import ArrayField
from django.contrib.postgres.search import SearchVectorField
from django.db import models

try:
    from pgvector.django import VectorField
except ImportError:
    VectorField = None  # pgvector not installed


class BaseModel(models.Model):
    """Abstract base with standard audit fields."""

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        abstract = True


class OrganizationModel(BaseModel):
    """Abstract base for multi-organization models."""

    organization = models.ForeignKey(
        "auth_core.Organizations", on_delete=models.CASCADE, related_name="%(class)ss"
    )

    class Meta:
        abstract = True


class RiskScoreHistory(OrganizationModel):
    """Org-scoped risk score history. Inherits organization FK from OrganizationModel."""

    department = models.TextField(null=True, blank=True)
    location = models.TextField(null=True, blank=True)
    risk_score = models.DecimalField(max_digits=5, decimal_places=2)
    training_completion_rate = models.DecimalField(max_digits=5, decimal_places=4)
    avg_quiz_score = models.DecimalField(max_digits=5, decimal_places=2)
    days_since_last_training = models.IntegerField(null=True, blank=True)
    pending_users = models.IntegerField(null=True, blank=True)
    at_risk_users = models.IntegerField(null=True, blank=True)
    created_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        db_table = "risk_score_history"
        verbose_name = "RiskScoreHistory"
        ordering = ["-created_at"]


class OrganizationRiskHistory(OrganizationModel):
    """Org-scoped aggregate risk history. Inherits organization FK from OrganizationModel."""

    overall_risk_score = models.DecimalField(max_digits=5, decimal_places=2)
    high_risk_departments = models.IntegerField(null=True, blank=True)
    total_users = models.IntegerField(null=True, blank=True)
    compliant_users = models.IntegerField(null=True, blank=True)
    at_risk_users = models.IntegerField(null=True, blank=True)
    created_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        db_table = "organization_risk_history"
        verbose_name = "OrganizationRiskHistory"
        ordering = ["-created_at"]


class EvidenceBundles(OrganizationModel):
    """Evidence bundle with lifecycle enforcement.

    Status transitions (INV: aligned with NzilaOS evidence lifecycle):
      draft → sealed  (call seal_bundle() — sets seal_envelope, content_hash, sealed_at)
      sealed → finalized
      finalized → archived
    Re-sealing a sealed bundle raises EvidenceSealViolationError.
    """

    STATUS_CHOICES = [
        ("draft", "Draft"),
        ("sealed", "Sealed"),  # cryptographic seal applied
        ("finalized", "Finalized"),
        ("archived", "Archived"),
    ]

    bundle_name = models.TextField(null=True, blank=True)
    bundle_type = models.TextField(null=True, blank=True)
    description = models.TextField(null=True, blank=True)
    tags = models.TextField(null=True, blank=True)
    status = models.CharField(
        choices=STATUS_CHOICES, max_length=19, default="draft", null=True, blank=True
    )
    created_by = models.UUIDField(null=True, blank=True)
    finalized_at = models.DateTimeField(null=True, blank=True)
    # — Seal fields (INV: NzilaOS SealEnvelope equivalent) —
    sealed_at = models.DateTimeField(
        null=True,
        blank=True,
        help_text="Timestamp of first-and-only seal. Immutable once set.",
    )
    seal_envelope = models.JSONField(
        null=True,
        blank=True,
        help_text="Serialized SealEnvelope: packDigest, artifactsMerkleRoot, sealVersion, sealedAt, optional hmacSignature.",
    )
    content_hash = models.CharField(
        max_length=64,
        null=True,
        blank=True,
        help_text="SHA-256 of canonical bundle content at seal time.",
    )
    previous_hash = models.CharField(
        max_length=64,
        null=True,
        blank=True,
        help_text="content_hash of previous EvidenceBundles record for this org (hash chain link).",
    )

    class Meta:
        db_table = "evidence_bundles"
        verbose_name = "EvidenceBundles"
        ordering = ["-created_at"]


class EvidenceBundleComponents(BaseModel):
    """Migrated from sql: 20250129000002_evidence_bundles.sql"""

    bundle_id = models.UUIDField(null=True, blank=True)
    component_type = models.TextField(null=True, blank=True)
    component_id = models.TextField(null=True, blank=True)
    component_title = models.TextField(null=True, blank=True)
    metadata = models.JSONField(default=dict, null=True, blank=True)
    included_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        db_table = "evidence_bundle_components"
        verbose_name = "EvidenceBundleComponents"


class EvidenceBundlePolicyMappings(BaseModel):
    """Migrated from sql: 20250129000002_evidence_bundles.sql"""

    COMPLIANCE_STATUS_CHOICES = [
        ("compliant", "Compliant"),
        ("non_compliant", "Non Compliant"),
        ("under_review", "Under Review"),
    ]

    bundle_id = models.UUIDField(null=True, blank=True)
    tribunal_case_id = models.TextField(null=True, blank=True)
    tribunal_case_title = models.TextField(null=True, blank=True)
    related_training_id = models.TextField(null=True, blank=True)
    related_training_title = models.TextField(null=True, blank=True)
    policy_reference = models.TextField(null=True, blank=True)
    policy_title = models.TextField(null=True, blank=True)
    mapping_rationale = models.TextField(null=True, blank=True)
    compliance_status = models.CharField(
        choices=COMPLIANCE_STATUS_CHOICES, max_length=23, null=True, blank=True
    )
    created_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        db_table = "evidence_bundle_policy_mappings"
        verbose_name = "EvidenceBundlePolicyMappings"
        ordering = ["-created_at"]


class EvidenceBundleTimeline(BaseModel):
    """Migrated from sql: 20250129000002_evidence_bundles.sql"""

    bundle_id = models.UUIDField(null=True, blank=True)
    event_date = models.DateTimeField(null=True, blank=True)
    event_type = models.TextField(null=True, blank=True)
    event_title = models.TextField(null=True, blank=True)
    event_description = models.TextField(null=True, blank=True)
    related_component_id = models.TextField(null=True, blank=True)
    related_component_type = models.TextField(null=True, blank=True)
    created_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        db_table = "evidence_bundle_timeline"
        verbose_name = "EvidenceBundleTimeline"
        ordering = ["-created_at"]


# ════════════════════════════════════════════════════════════════════════════
# ABR Identity Vault + Dual-Control + Access Log models
# — Phase 2 confidential-reporting wire
# — org_id stored as UUIDField (no FK to auth_core) so tables are
#   SQLite-compatible in test environments. Org boundary enforced at the
#   service/view layer.
# ════════════════════════════════════════════════════════════════════════════


class AbrReporterIdentity(BaseModel):
    """
    Org-scoped, encryption-at-rest placeholder for reporter PII.
    Actual PII lives in IdentityVaultEntry. This record links a vault
    entry back to an org without exposing the PII directly.
    """

    org_id = models.UUIDField(
        db_index=True,
        help_text="Owning organization (UUID, no FK — enforced at app layer).",
    )
    vault_entry_id = models.UUIDField(
        unique=True,
        help_text="ID of the corresponding IdentityVaultEntry.",
    )
    key_id = models.CharField(
        max_length=64,
        default="default",
        help_text="Encryption key ID used for the vault entry.",
    )
    is_active = models.BooleanField(
        default=True,
        help_text="False once the reporter identity is permanently redacted.",
    )
    created_by = models.CharField(
        max_length=255,
        help_text="User ID of the compliance officer who created the record.",
    )

    class Meta:
        db_table = "abr_reporter_identity"
        verbose_name = "AbrReporterIdentity"
        indexes = [
            models.Index(fields=["org_id", "vault_entry_id"]),
            models.Index(fields=["org_id", "is_active"]),
        ]


class AbrCase(BaseModel):
    """
    ABR case record. Contains ONLY non-PII metadata.
    PII lives exclusively in the identity vault, linked by identity_id.
    """

    STATUS_CHOICES = [
        ("open", "Open"),
        ("under_review", "Under Review"),
        ("escalated", "Escalated"),
        ("closed", "Closed"),
        ("archived", "Archived"),
    ]

    SEVERITY_CHOICES = [
        ("low", "Low"),
        ("medium", "Medium"),
        ("high", "High"),
        ("critical", "Critical"),
    ]

    org_id = models.UUIDField(
        db_index=True,
        help_text="Owning organization (UUID, no FK — enforced at app layer).",
    )
    # Identity link: nullable; only populated when reporter consented to identification
    # and dual-control was approved for unmask.
    identity_id = models.ForeignKey(
        AbrReporterIdentity,
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name="cases",
        help_text="Linked identity record. Requires dual-control approval to populate.",
    )
    case_number = models.CharField(
        max_length=64,
        unique=True,
        help_text="Human-readable case reference (e.g. ABR-2026-001).",
    )
    title = models.CharField(
        max_length=255,
        help_text="Non-identifying case title.",
    )
    status = models.CharField(
        max_length=20,
        choices=STATUS_CHOICES,
        default="open",
    )
    severity = models.CharField(
        max_length=10,
        choices=SEVERITY_CHOICES,
        default="medium",
    )
    category = models.CharField(
        max_length=100,
        blank=True,
        default="",
        help_text="Incident category (e.g. workplace-harassment, financial-misconduct).",
    )
    description = models.TextField(
        blank=True,
        default="",
        help_text="Case description — never contains reporter PII.",
    )
    closed_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        db_table = "abr_case"
        verbose_name = "AbrCase"
        indexes = [
            models.Index(fields=["org_id", "status"]),
            models.Index(fields=["org_id", "severity"]),
            models.Index(fields=["org_id", "created_at"]),
        ]

    def __str__(self) -> str:
        return f"{self.case_number} — {self.title} [{self.status}]"


class AbrIdentityAccessLog(BaseModel):
    """
    Immutable audit log: every access to a reporter identity must produce
    a record here. Range-indexed on (org_id, case_id) for efficient reporting.
    """

    org_id = models.UUIDField(
        db_index=True,
        help_text="Owning organization.",
    )
    case_id = models.UUIDField(
        db_index=True,
        help_text="Case the identity was accessed in context of.",
    )
    identity_id = models.UUIDField(
        help_text="ID of the AbrReporterIdentity that was accessed.",
    )
    accessed_by = models.CharField(
        max_length=255,
        help_text="User ID of the accessor.",
    )
    # Justification is mandatory — enforced at the view layer.
    justification = models.TextField(
        help_text="Mandatory reason for accessing identity data.",
    )
    accessed_at = models.DateTimeField(auto_now_add=True)
    access_type = models.CharField(
        max_length=50,
        default="view",
        help_text="Type of access: view, export, unmask.",
    )

    class Meta:
        db_table = "abr_identity_access_log"
        verbose_name = "AbrIdentityAccessLog"
        # Append-only semantics: managed_field prevents updates
        indexes = [
            models.Index(fields=["org_id", "case_id"]),
            models.Index(fields=["org_id", "accessed_at"]),
            models.Index(fields=["accessed_by", "accessed_at"]),
        ]


class AbrSensitiveActionRequest(BaseModel):
    """
    Dual-control request for a sensitive ABR action.
    Cannot be approved by the requester (enforced in approve()).
    """

    ACTION_CHOICES = [
        ("case-close", "Close Case"),
        ("severity-change", "Change Severity"),
        ("identity-unmask", "Unmask Reporter Identity"),
        ("evidence-export", "Export Case Evidence"),
    ]

    STATUS_CHOICES = [
        ("pending", "Pending Approval"),
        ("approved", "Approved"),
        ("rejected", "Rejected"),
        ("expired", "Expired"),
        ("executed", "Executed"),
    ]

    org_id = models.UUIDField(
        db_index=True,
        help_text="Owning organization.",
    )
    case_id = models.UUIDField(
        db_index=True,
        help_text="Case this request pertains to.",
    )
    action = models.CharField(
        max_length=32,
        choices=ACTION_CHOICES,
    )
    requested_by = models.CharField(
        max_length=255,
        help_text="User ID of the requesting principal.",
    )
    justification = models.TextField(
        help_text="Why this action is required.",
    )
    status = models.CharField(
        max_length=16,
        choices=STATUS_CHOICES,
        default="pending",
    )
    expires_at = models.DateTimeField(
        help_text="Auto-expiry timestamp (default: 24 h from creation).",
    )
    executed_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        db_table = "abr_sensitive_action_requests"
        verbose_name = "AbrSensitiveActionRequest"
        indexes = [
            models.Index(fields=["org_id", "case_id"]),
            models.Index(fields=["org_id", "status"]),
            models.Index(fields=["requested_by", "status"]),
        ]

    def __str__(self) -> str:
        return (
            f"SensitiveAction({self.action}, case={self.case_id}, status={self.status})"
        )


class AbrSensitiveActionApproval(BaseModel):
    """
    Approval record for a dual-control request.
    One record per approval/rejection decision.
    approver_id MUST differ from request.requested_by (enforced in approve()).
    """

    org_id = models.UUIDField(
        db_index=True,
        help_text="Owning organization — mirrors request.org_id for direct org-scope queries.",
    )
    request = models.ForeignKey(
        AbrSensitiveActionRequest,
        on_delete=models.CASCADE,
        related_name="approvals",
    )
    approver_id = models.CharField(
        max_length=255,
        help_text="User ID of the approving/rejecting principal.",
    )
    decision = models.CharField(
        max_length=10,
        choices=[("approved", "Approved"), ("rejected", "Rejected")],
    )
    notes = models.TextField(blank=True, default="")
    decided_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = "abr_sensitive_action_approvals"
        verbose_name = "AbrSensitiveActionApproval"
        indexes = [
            models.Index(fields=["request", "decision"]),
        ]

    def __str__(self) -> str:
        return (
            f"Approval({self.decision}, req={self.request_id}, by={self.approver_id})"
        )


class AbrCaseTeamMember(BaseModel):
    """
    Maps users to cases. Read access to case details requires membership
    OR compliance-override role. Enforced at the view layer.
    """

    ROLE_CHOICES = [
        ("investigator", "Investigator"),
        ("reviewer", "Reviewer"),
        ("observer", "Observer"),
        ("compliance-officer", "Compliance Officer"),
    ]

    org_id = models.UUIDField(
        db_index=True,
        help_text="Owning organization.",
    )
    case = models.ForeignKey(
        AbrCase,
        on_delete=models.CASCADE,
        related_name="team_members",
    )
    user_id = models.CharField(
        max_length=255,
        help_text="Clerk user ID of the team member.",
    )
    role = models.CharField(
        max_length=30,
        choices=ROLE_CHOICES,
        default="observer",
    )
    added_by = models.CharField(
        max_length=255,
        help_text="User ID of the person who added this team member.",
    )

    class Meta:
        db_table = "abr_case_team_members"
        verbose_name = "AbrCaseTeamMember"
        unique_together = [("case", "user_id")]
        indexes = [
            models.Index(fields=["org_id", "case"]),
            models.Index(fields=["user_id", "org_id"]),
        ]

    def __str__(self) -> str:
        return f"TeamMember({self.user_id}, case={self.case_id}, role={self.role})"
